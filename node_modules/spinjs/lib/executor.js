"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var containerized = require("containerized");
var crypto = require("crypto");
var fs = require("fs");
var http = require("http");
var ip = require("ip");
var _ = require("lodash");
var minilog = require("minilog");
var mkdirp = require("mkdirp");
var path = require("path");
var source_list_map_1 = require("source-list-map");
var url = require("url");
var webpack_sources_1 = require("webpack-sources");
var liveReloadMiddleware_1 = require("./plugins/react-native/liveReloadMiddleware");
var requireModule_1 = require("./requireModule");
var expoPorts = {};
minilog.enable();
var spinLogger = minilog('spin');
process.on('uncaughtException', function (ex) {
    spinLogger.error(ex);
});
process.on('unhandledRejection', function (reason) {
    spinLogger.error(reason);
});
var __WINDOWS__ = /^win/.test(process.platform);
var server;
var startBackend = false;
var backendFirstStart = true;
var nodeDebugOpt;
process.on('exit', function () {
    if (server) {
        server.kill('SIGTERM');
    }
});
var spawnServer = function (serverPath, debugOpt, logger) {
    server = child_process_1.spawn('node', [debugOpt, serverPath], { stdio: [0, 1, 2] });
    logger("Spawning " + ['node', debugOpt, serverPath].join(' '));
    server.on('exit', function (code) {
        if (code === 250) {
            startBackend = true;
        }
        logger('Backend has been stopped');
        server = undefined;
        runServer(serverPath, logger);
    });
};
var runServer = function (serverPath, logger) {
    if (!fs.existsSync(serverPath)) {
        throw new Error("Backend doesn't exist at " + serverPath + ", exiting");
    }
    if (startBackend) {
        startBackend = false;
        logger('Starting backend');
        if (!nodeDebugOpt) {
            child_process_1.exec('node -v', function (error, stdout, stderr) {
                if (error) {
                    spinLogger.error(error);
                    process.exit(1);
                }
                var nodeVersion = stdout.match(/^v([0-9]+)\.([0-9]+)\.([0-9]+)/);
                var nodeMajor = parseInt(nodeVersion[1], 10);
                var nodeMinor = parseInt(nodeVersion[2], 10);
                nodeDebugOpt = nodeMajor >= 6 || (nodeMajor === 6 && nodeMinor >= 9) ? '--inspect' : '--debug';
                spawnServer(serverPath, nodeDebugOpt, logger);
            });
        }
        else {
            spawnServer(serverPath, nodeDebugOpt, logger);
        }
    }
};
var webpackReporter = function (watch, outputPath, log, err, stats) {
    if (err) {
        log(err.stack);
        throw new Error('Build error');
    }
    if (stats) {
        log(stats.toString({
            hash: false,
            version: false,
            timings: true,
            assets: false,
            chunks: false,
            modules: false,
            reasons: false,
            children: false,
            source: true,
            errors: true,
            errorDetails: true,
            warnings: true,
            publicPath: false,
            colors: true
        }));
        if (!watch) {
            mkdirp.sync(outputPath);
            fs.writeFileSync(path.join(outputPath, 'stats.json'), JSON.stringify(stats.toJson()));
        }
    }
};
var frontendVirtualModules;
var MobileAssetsPlugin = (function () {
    function MobileAssetsPlugin(vendorAssets) {
        this.vendorAssets = vendorAssets || [];
    }
    MobileAssetsPlugin.prototype.apply = function (compiler) {
        var _this = this;
        compiler.plugin('after-compile', function (compilation, callback) {
            compilation.chunks.forEach(function (chunk) {
                chunk.files.forEach(function (file) {
                    if (file.endsWith('.bundle')) {
                        var assets_1 = _this.vendorAssets;
                        compilation.modules.forEach(function (module) {
                            if (module._asset) {
                                assets_1.push(module._asset);
                            }
                        });
                        compilation.assets[file.replace('.bundle', '') + '.assets'] = new webpack_sources_1.RawSource(JSON.stringify(assets_1));
                    }
                });
            });
            callback();
        });
    };
    return MobileAssetsPlugin;
}());
var startClientWebpack = function (hasBackend, watch, builder, options) {
    var webpack = requireModule_1.default('webpack');
    var config = builder.config;
    config.plugins.push(frontendVirtualModules);
    var logger = minilog("webpack-for-" + config.name);
    try {
        var reporter = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return webpackReporter.apply(void 0, [watch, config.output.path, logger].concat(args));
        };
        if (watch) {
            startWebpackDevServer(hasBackend, builder, options, reporter, logger);
        }
        else {
            if (builder.stack.platform !== 'web') {
                config.plugins.push(new MobileAssetsPlugin());
            }
            var compiler = webpack(config);
            compiler.run(reporter);
        }
    }
    catch (err) {
        logger(err.message, err.stack);
    }
};
var backendReloadCount = 0;
var increaseBackendReloadCount = function () {
    backendReloadCount++;
    frontendVirtualModules.writeModule('node_modules/backend_reload.js', "var count = " + backendReloadCount + ";\n");
};
var startServerWebpack = function (watch, builder, options) {
    var config = builder.config;
    var logger = minilog("webpack-for-" + config.name);
    try {
        var webpack = requireModule_1.default('webpack');
        var reporter = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return webpackReporter.apply(void 0, [watch, config.output.path, logger].concat(args));
        };
        var compiler = webpack(config);
        if (watch) {
            compiler.plugin('compilation', function (compilation) {
                compilation.plugin('after-optimize-assets', function (assets) {
                    var mapKey = _.findKey(assets, function (v, k) { return k.endsWith('.map'); });
                    if (mapKey) {
                        var srcMap = JSON.parse(assets[mapKey]._value);
                        for (var _i = 0, _a = Object.keys(srcMap.sources); _i < _a.length; _i++) {
                            var idx = _a[_i];
                            srcMap.sources[idx] = srcMap.sources[idx].split(';')[0];
                        }
                        assets[mapKey]._value = JSON.stringify(srcMap);
                    }
                });
            });
            compiler.watch({}, reporter);
            compiler.plugin('done', function (stats) {
                if (!stats.compilation.errors.length) {
                    var output = config.output;
                    startBackend = true;
                    if (server) {
                        if (!__WINDOWS__) {
                            server.kill('SIGUSR2');
                        }
                        if (options.frontendRefreshOnBackendChange) {
                            for (var _i = 0, _a = stats.compilation.modules; _i < _a.length; _i++) {
                                var module_1 = _a[_i];
                                if (module_1.built && module_1.resource && module_1.resource.indexOf(path.resolve('./src/server')) === 0) {
                                    logger.debug('Force front-end current page refresh, due to change in backend at:', module_1.resource);
                                    increaseBackendReloadCount();
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        runServer(path.join(output.path, 'index.js'), logger);
                    }
                }
            });
        }
        else {
            compiler.run(reporter);
        }
    }
    catch (err) {
        logger(err.message, err.stack);
    }
};
var openFrontend = function (builder, logger) {
    var openurl = requireModule_1.default('openurl');
    try {
        if (builder.stack.hasAny('web')) {
            var lanUrl = "http://" + ip.address() + ":" + builder.config.devServer.port;
            var localUrl = "http://localhost:" + builder.config.devServer.port;
            if (containerized() || builder.openBrowser === false) {
                logger.info("App is running at, Local: " + localUrl + " LAN: " + lanUrl);
            }
            else {
                openurl.open(localUrl);
            }
        }
        else if (builder.stack.hasAny('react-native')) {
            startExpoProject(builder.config, builder.stack.platform, logger);
        }
    }
    catch (e) {
        logger.error(e.stack);
    }
};
var debugMiddleware = function (req, res, next) {
    if (['/debug', '/debug/bundles'].indexOf(req.path) >= 0) {
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end('<!doctype html><div><a href="/debug/bundles">Cached Bundles</a></div>');
    }
    else {
        next();
    }
};
var startWebpackDevServer = function (hasBackend, builder, options, reporter, logger) {
    var webpack = requireModule_1.default('webpack');
    var connect = requireModule_1.default('connect');
    var compression = requireModule_1.default('compression');
    var mime = requireModule_1.default('mime', requireModule_1.default.resolve('webpack-dev-middleware'));
    var webpackDevMiddleware = requireModule_1.default('webpack-dev-middleware');
    var webpackHotMiddleware = requireModule_1.default('webpack-hot-middleware');
    var httpProxyMiddleware = requireModule_1.default('http-proxy-middleware');
    var waitOn = requireModule_1.default('wait-on');
    var config = builder.config;
    var platform = builder.stack.platform;
    var configOutputPath = config.output.path;
    config.output.path = '/';
    var vendorHashesJson;
    var vendorSourceListMap;
    var vendorSource;
    var vendorMap;
    if (options.webpackDll && builder.child) {
        var name = "vendor_" + platform;
        var jsonPath = path.join(options.dllBuildDir, name + "_dll.json");
        config.plugins.push(new webpack.DllReferencePlugin({
            context: process.cwd(),
            manifest: requireModule_1.default('./' + jsonPath)
        }));
        vendorHashesJson = JSON.parse(fs.readFileSync(path.join(options.dllBuildDir, name + "_dll_hashes.json")).toString());
        vendorSource = new webpack_sources_1.RawSource(fs.readFileSync(path.join(options.dllBuildDir, vendorHashesJson.name)).toString() + '\n');
        vendorMap = new webpack_sources_1.RawSource(fs.readFileSync(path.join(options.dllBuildDir, vendorHashesJson.name + '.map')).toString());
        if (platform !== 'web') {
            var vendorAssets = JSON.parse(fs.readFileSync(path.join(options.dllBuildDir, vendorHashesJson.name + '.assets')).toString());
            config.plugins.push(new MobileAssetsPlugin(vendorAssets));
        }
        vendorSourceListMap = source_list_map_1.fromStringWithSourceMap(vendorSource.source(), JSON.parse(vendorMap.source()));
    }
    var compiler = webpack(config);
    compiler.plugin('after-emit', function (compilation, callback) {
        if (backendFirstStart) {
            if (hasBackend) {
                logger.debug('Webpack dev server is waiting for backend to start...');
                var host = url.parse(options.backendUrl.replace('{ip}', ip.address())).host;
                waitOn({ resources: ["tcp:" + host] }, function (err) {
                    if (err) {
                        logger.error(err);
                        callback();
                    }
                    else {
                        logger.debug('Backend has been started, resuming webpack dev server...');
                        backendFirstStart = false;
                        callback();
                    }
                });
            }
            else {
                callback();
            }
        }
        else {
            callback();
        }
    });
    if (options.webpackDll && builder.child && platform !== 'web') {
        compiler.plugin('after-compile', function (compilation, callback) {
            compilation.chunks.forEach(function (chunk) {
                chunk.files.forEach(function (file) {
                    if (file.endsWith('.bundle')) {
                        var sourceListMap = new source_list_map_1.SourceListMap();
                        sourceListMap.add(vendorSourceListMap);
                        sourceListMap.add(source_list_map_1.fromStringWithSourceMap(compilation.assets[file].source(), JSON.parse(compilation.assets[file + '.map'].source())));
                        var sourceAndMap = sourceListMap.toStringWithSourceMap({ file: file });
                        compilation.assets[file] = new webpack_sources_1.RawSource(sourceAndMap.source);
                        compilation.assets[file + '.map'] = new webpack_sources_1.RawSource(JSON.stringify(sourceAndMap.map));
                    }
                });
            });
            callback();
        });
    }
    if (options.webpackDll && builder.child && platform === 'web' && !options.ssr) {
        compiler.plugin('after-compile', function (compilation, callback) {
            compilation.assets[vendorHashesJson.name] = vendorSource;
            compilation.assets[vendorHashesJson.name + '.map'] = vendorMap;
            callback();
        });
        compiler.plugin('compilation', function (compilation) {
            compilation.plugin('html-webpack-plugin-before-html-processing', function (htmlPluginData, callback) {
                htmlPluginData.assets.js.unshift('/' + vendorHashesJson.name);
                callback(null, htmlPluginData);
            });
        });
    }
    var frontendFirstStart = true;
    compiler.plugin('done', function (stats) {
        var dir = configOutputPath;
        mkdirp.sync(dir);
        if (stats.compilation.assets['assets.json']) {
            var assetsMap_1 = JSON.parse(stats.compilation.assets['assets.json'].source());
            _.each(stats.toJson().assetsByChunkName, function (assets, bundle) {
                var bundleJs = assets.constructor === Array ? assets[0] : assets;
                assetsMap_1[bundle + ".js"] = bundleJs;
                if (assets.length > 1) {
                    assetsMap_1[bundle + ".js.map"] = bundleJs + ".map";
                }
            });
            if (options.webpackDll) {
                assetsMap_1['vendor.js'] = vendorHashesJson.name;
            }
            fs.writeFileSync(path.join(dir, 'assets.json'), JSON.stringify(assetsMap_1));
        }
        if (frontendFirstStart) {
            frontendFirstStart = false;
            openFrontend(builder, logger);
        }
    });
    var app = connect();
    var serverInstance = http.createServer(app);
    var webSocketProxy;
    var messageSocket;
    var wsProxy;
    var ms;
    var inspectorProxy;
    if (platform !== 'web') {
        mime.define({ 'application/javascript': ['bundle'] });
        mime.define({ 'application/json': ['assets'] });
        messageSocket = requireModule_1.default('react-native/local-cli/server/util/messageSocket.js');
        webSocketProxy = requireModule_1.default('react-native/local-cli/server/util/webSocketProxy.js');
        try {
            var InspectorProxy = requireModule_1.default('react-native/local-cli/server/util/inspectorProxy.js');
            inspectorProxy = new InspectorProxy();
        }
        catch (ignored) { }
        var copyToClipBoardMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/copyToClipBoardMiddleware');
        var cpuProfilerMiddleware = void 0;
        try {
            cpuProfilerMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/cpuProfilerMiddleware');
        }
        catch (ignored) { }
        var getDevToolsMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/getDevToolsMiddleware');
        var heapCaptureMiddleware = void 0;
        try {
            heapCaptureMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/heapCaptureMiddleware.js');
        }
        catch (ignored) { }
        var indexPageMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/indexPage');
        var loadRawBodyMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/loadRawBodyMiddleware');
        var openStackFrameInEditorMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/openStackFrameInEditorMiddleware');
        var statusPageMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/statusPageMiddleware.js');
        var systraceProfileMiddleware = requireModule_1.default('react-native/local-cli/server/middleware/systraceProfileMiddleware.js');
        var unless = requireModule_1.default('react-native/local-cli/server/middleware/unless');
        var symbolicateMiddleware = requireModule_1.default('haul/src/server/middleware/symbolicateMiddleware');
        var args = {
            port: config.devServer.port,
            projectRoots: [path.resolve('.')]
        };
        app
            .use(loadRawBodyMiddleware)
            .use(function (req, res, next) {
            req.path = req.url.split('?')[0];
            next();
        })
            .use(compression())
            .use(getDevToolsMiddleware(args, function () { return wsProxy && wsProxy.isChromeConnected(); }))
            .use(getDevToolsMiddleware(args, function () { return ms && ms.isChromeConnected(); }))
            .use(liveReloadMiddleware_1.default(compiler))
            .use(symbolicateMiddleware(compiler))
            .use(openStackFrameInEditorMiddleware(args))
            .use(copyToClipBoardMiddleware)
            .use(statusPageMiddleware)
            .use(systraceProfileMiddleware)
            .use(indexPageMiddleware)
            .use(debugMiddleware)
            .use(function (req, res, next) {
            var platformPrefix = "/assets/" + platform + "/";
            if (req.path.indexOf(platformPrefix) === 0) {
                var origPath = path.join(path.resolve('.'), req.path.substring(platformPrefix.length));
                var extension_1 = path.extname(origPath);
                var basePath_1 = path.join(path.dirname(origPath), path.basename(origPath, extension_1));
                var files = ["." + platform, '.native', ''].map(function (suffix) { return basePath_1 + suffix + extension_1; });
                var assetExists = false;
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var filePath = files_1[_i];
                    if (fs.existsSync(filePath)) {
                        assetExists = true;
                        res.writeHead(200, { 'Content-Type': mime.lookup(filePath) });
                        fs.createReadStream(filePath).pipe(res);
                    }
                }
                if (!assetExists) {
                    logger.warn('Asset not found:', origPath);
                    res.writeHead(404, { 'Content-Type': 'plain' });
                    res.end('Asset: ' + origPath + ' not found. Tried: ' + JSON.stringify(files));
                }
            }
            else {
                next();
            }
        });
        if (heapCaptureMiddleware) {
            app.use(heapCaptureMiddleware);
        }
        if (cpuProfilerMiddleware) {
            app.use(cpuProfilerMiddleware);
        }
        if (inspectorProxy) {
            app.use(unless('/inspector', inspectorProxy.processRequest.bind(inspectorProxy)));
        }
    }
    var devMiddleware = webpackDevMiddleware(compiler, _.merge({}, config.devServer, {
        reporter: function (_a) {
            var state = _a.state, stats = _a.stats;
            if (state) {
                logger('bundle is now VALID.');
            }
            else {
                logger('bundle is now INVALID.');
            }
            reporter(null, stats);
        }
    }));
    app
        .use(function (req, res, next) {
        if (platform !== 'web') {
            var origSetHeader_1 = res.setHeader;
            res.setHeader = function (key, value) {
                var val = value;
                if (key === 'Content-Type' && value.indexOf('application/javascript') >= 0) {
                    val = value.split(';')[0];
                }
                origSetHeader_1.call(res, key, val);
            };
        }
        return devMiddleware(req, res, next);
    })
        .use(webpackHotMiddleware(compiler, { log: false }));
    if (config.devServer.proxy) {
        Object.keys(config.devServer.proxy).forEach(function (key) {
            app.use(httpProxyMiddleware(key, config.devServer.proxy[key]));
        });
    }
    logger("Webpack " + config.name + " dev server listening on http://localhost:" + config.devServer.port);
    serverInstance.listen(config.devServer.port, function () {
        if (platform !== 'web') {
            wsProxy = webSocketProxy.attachToServer(serverInstance, '/debugger-proxy');
            ms = messageSocket.attachToServer(serverInstance, '/message');
            webSocketProxy.attachToServer(serverInstance, '/devtools');
            if (inspectorProxy) {
                inspectorProxy.attachToServer(serverInstance, '/inspector');
            }
        }
    });
    serverInstance.timeout = 0;
    serverInstance.keepAliveTimeout = 0;
};
var isDllValid = function (platform, config, options, logger) {
    var name = "vendor_" + platform;
    try {
        var hashesPath = path.join(options.dllBuildDir, name + "_dll_hashes.json");
        if (!fs.existsSync(hashesPath)) {
            return false;
        }
        var meta = JSON.parse(fs.readFileSync(hashesPath).toString());
        if (!fs.existsSync(path.join(options.dllBuildDir, meta.name))) {
            return false;
        }
        if (!_.isEqual(meta.modules, config.entry.vendor)) {
            return false;
        }
        var json = JSON.parse(fs.readFileSync(path.join(options.dllBuildDir, name + "_dll.json")).toString());
        for (var _i = 0, _a = Object.keys(json.content); _i < _a.length; _i++) {
            var filename = _a[_i];
            if (filename.indexOf(' ') < 0) {
                if (!fs.existsSync(filename)) {
                    logger.warn(name + " DLL need to be regenerated, file: " + filename + " is missing.");
                    return false;
                }
                var hash = crypto
                    .createHash('md5')
                    .update(fs.readFileSync(filename))
                    .digest('hex');
                if (meta.hashes[filename] !== hash) {
                    logger.warn("Hash for " + name + " DLL file " + filename + " has changed, need to rebuild it");
                    return false;
                }
            }
        }
        return true;
    }
    catch (e) {
        logger.warn("Error checking vendor bundle " + name + ", regenerating it...", e);
        return false;
    }
};
var buildDll = function (platform, config, options) {
    var webpack = requireModule_1.default('webpack');
    return new Promise(function (done) {
        var name = "vendor_" + platform;
        var logger = minilog("webpack-for-" + config.name);
        var reporter = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return webpackReporter.apply(void 0, [true, config.output.path, logger].concat(args));
        };
        if (!isDllValid(platform, config, options, logger)) {
            logger.info("Generating " + name + " DLL bundle with modules:\n" + JSON.stringify(config.entry.vendor));
            mkdirp.sync(options.dllBuildDir);
            var compiler = webpack(config);
            compiler.plugin('done', function (stats) {
                try {
                    var json = JSON.parse(fs.readFileSync(path.join(options.dllBuildDir, name + "_dll.json")).toString());
                    var vendorKey = _.findKey(stats.compilation.assets, function (v, key) { return key.startsWith('vendor') && key.endsWith('_dll.js'); });
                    var assets_2 = [];
                    stats.compilation.modules.forEach(function (module) {
                        if (module._asset) {
                            assets_2.push(module._asset);
                        }
                    });
                    fs.writeFileSync(path.join(options.dllBuildDir, vendorKey + ".assets"), JSON.stringify(assets_2));
                    var meta = { name: vendorKey, hashes: {}, modules: config.entry.vendor };
                    for (var _i = 0, _a = Object.keys(json.content); _i < _a.length; _i++) {
                        var filename = _a[_i];
                        if (filename.indexOf(' ') < 0) {
                            meta.hashes[filename] = crypto
                                .createHash('md5')
                                .update(fs.readFileSync(filename))
                                .digest('hex');
                            fs.writeFileSync(path.join(options.dllBuildDir, name + "_dll_hashes.json"), JSON.stringify(meta));
                        }
                    }
                }
                catch (e) {
                    logger.error(e.stack);
                    process.exit(1);
                }
                done();
            });
            compiler.run(reporter);
        }
        else {
            done();
        }
    });
};
var setupExpoDir = function (dir, platform) {
    var reactNativeDir = path.join(dir, 'node_modules', 'react-native');
    mkdirp.sync(path.join(reactNativeDir, 'local-cli'));
    fs.writeFileSync(path.join(reactNativeDir, 'package.json'), fs.readFileSync('node_modules/react-native/package.json'));
    fs.writeFileSync(path.join(reactNativeDir, 'local-cli/cli.js'), '');
    var pkg = JSON.parse(fs.readFileSync('package.json').toString());
    var origDeps = pkg.dependencies;
    pkg.dependencies = { 'react-native': origDeps['react-native'] };
    if (platform !== 'all') {
        pkg.name = pkg.name + '-' + platform;
    }
    pkg.main = "index.mobile";
    fs.writeFileSync(path.join(dir, 'package.json'), JSON.stringify(pkg));
    var appJson = JSON.parse(fs.readFileSync('app.json').toString());
    if (appJson.expo.icon) {
        appJson.expo.icon = path.join(path.resolve('.'), appJson.expo.icon);
    }
    fs.writeFileSync(path.join(dir, 'app.json'), JSON.stringify(appJson));
    if (platform !== 'all') {
        fs.writeFileSync(path.join(dir, '.exprc'), JSON.stringify({ manifestPort: expoPorts[platform] }));
    }
};
var startExpoServer = function (projectRoot, packagerPort) { return __awaiter(_this, void 0, void 0, function () {
    var _a, Config, Project, ProjectSettings;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = requireModule_1.default('xdl'), Config = _a.Config, Project = _a.Project, ProjectSettings = _a.ProjectSettings;
                Config.validation.reactNativeVersionWarnings = false;
                Config.developerTool = 'crna';
                Config.offline = true;
                return [4, Project.startExpoServerAsync(projectRoot)];
            case 1:
                _b.sent();
                return [4, ProjectSettings.setPackagerInfoAsync(projectRoot, {
                        packagerPort: packagerPort
                    })];
            case 2:
                _b.sent();
                return [2];
        }
    });
}); };
var startExpoProject = function (config, platform, logger) { return __awaiter(_this, void 0, void 0, function () {
    var _a, UrlUtils, Android, Simulator, qr, projectRoot, address, localAddress, _b, success, error, _c, success, msg, e_1;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                _a = requireModule_1.default('xdl'), UrlUtils = _a.UrlUtils, Android = _a.Android, Simulator = _a.Simulator;
                qr = requireModule_1.default('qrcode-terminal');
                _d.label = 1;
            case 1:
                _d.trys.push([1, 9, , 10]);
                projectRoot = path.join(path.resolve('.'), '.expo', platform);
                setupExpoDir(projectRoot, platform);
                return [4, startExpoServer(projectRoot, config.devServer.port)];
            case 2:
                _d.sent();
                return [4, UrlUtils.constructManifestUrlAsync(projectRoot)];
            case 3:
                address = _d.sent();
                return [4, UrlUtils.constructManifestUrlAsync(projectRoot, {
                        hostType: 'localhost'
                    })];
            case 4:
                localAddress = _d.sent();
                logger.info("Expo address for " + platform + ", Local: " + localAddress + ", LAN: " + address);
                logger.info("To open this app on your phone scan this QR code in Expo Client (if it doesn't get started automatically)");
                qr.generate(address, function (code) {
                    logger.info('\n' + code);
                });
                if (!!containerized()) return [3, 8];
                if (!(platform === 'android')) return [3, 6];
                return [4, Android.openProjectAsync(projectRoot)];
            case 5:
                _b = _d.sent(), success = _b.success, error = _b.error;
                if (!success) {
                    logger.error(error.message);
                }
                return [3, 8];
            case 6:
                if (!(platform === 'ios')) return [3, 8];
                return [4, Simulator.openUrlInSimulatorSafeAsync(localAddress)];
            case 7:
                _c = _d.sent(), success = _c.success, msg = _c.msg;
                if (!success) {
                    logger.error('Failed to start Simulator: ', msg);
                }
                _d.label = 8;
            case 8: return [3, 10];
            case 9:
                e_1 = _d.sent();
                logger.error(e_1.stack);
                return [3, 10];
            case 10: return [2];
        }
    });
}); };
var startWebpack = function (platforms, watch, builder, options) { return __awaiter(_this, void 0, void 0, function () {
    var VirtualModules;
    return __generator(this, function (_a) {
        VirtualModules = requireModule_1.default('webpack-virtual-modules');
        if (!frontendVirtualModules) {
            frontendVirtualModules = new VirtualModules({ 'node_modules/backend_reload.js': '' });
        }
        if (builder.stack.platform === 'server') {
            startServerWebpack(watch, builder, options);
        }
        else {
            startClientWebpack(!!platforms.server, watch, builder, options);
        }
        return [2];
    });
}); };
var allocateExpoPorts = function (expoPlatforms) { return __awaiter(_this, void 0, void 0, function () {
    var startPort, freeportAsync, _i, expoPlatforms_1, platform, expoPort;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                startPort = 19000;
                freeportAsync = requireModule_1.default('freeport-async');
                _i = 0, expoPlatforms_1 = expoPlatforms;
                _a.label = 1;
            case 1:
                if (!(_i < expoPlatforms_1.length)) return [3, 4];
                platform = expoPlatforms_1[_i];
                return [4, freeportAsync(startPort)];
            case 2:
                expoPort = _a.sent();
                expoPorts[platform] = expoPort;
                startPort = expoPort + 1;
                _a.label = 3;
            case 3:
                _i++;
                return [3, 1];
            case 4: return [2];
        }
    });
}); };
var startExpoProdServer = function (options, logger) { return __awaiter(_this, void 0, void 0, function () {
    var connect, mime, compression, packagerPort, projectRoot, app, serverInstance;
    return __generator(this, function (_a) {
        connect = requireModule_1.default('connect');
        mime = requireModule_1.default('mime', requireModule_1.default.resolve('webpack-dev-middleware'));
        compression = requireModule_1.default('compression');
        logger.info("Starting Expo prod server");
        packagerPort = 3030;
        projectRoot = path.join(path.resolve('.'), '.expo', 'all');
        startExpoServer(projectRoot, packagerPort);
        app = connect();
        app
            .use(function (req, res, next) {
            req.path = req.url.split('?')[0];
            next();
        })
            .use(compression())
            .use(debugMiddleware)
            .use(function (req, res, next) {
            var platform = url.parse(req.url, true).query.platform;
            if (platform) {
                var filePath = path.join(options.frontendBuildDir, platform, req.path);
                if (fs.existsSync(filePath)) {
                    res.writeHead(200, { 'Content-Type': mime.lookup(filePath) });
                    fs.createReadStream(filePath).pipe(res);
                }
                else {
                    res.writeHead(404, { 'Content-Type': 'application/json' });
                    res.end("{'message': 'File not found: " + filePath + "'}");
                }
            }
            else {
                next();
            }
        });
        serverInstance = http.createServer(app);
        logger.info("Production mobile packager listening on http://localhost:" + packagerPort);
        serverInstance.listen(packagerPort);
        serverInstance.timeout = 0;
        serverInstance.keepAliveTimeout = 0;
        return [2];
    });
}); };
var startExp = function (options, logger) { return __awaiter(_this, void 0, void 0, function () {
    var projectRoot, exp;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                projectRoot = path.join(process.cwd(), '.expo', 'all');
                setupExpoDir(projectRoot, 'all');
                if (!(['ba', 'bi', 'build:android', 'build:ios'].indexOf(process.argv[3]) >= 0)) return [3, 2];
                return [4, startExpoProdServer(options, logger)];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2:
                exp = child_process_1.spawn(path.join(process.cwd(), 'node_modules/.bin/exp'), process.argv.splice(3), {
                    cwd: projectRoot,
                    stdio: [0, 1, 2]
                });
                exp.on('exit', function (code) {
                    process.exit(code);
                });
                return [2];
        }
    });
}); };
var execute = function (cmd, argv, builders, options) {
    if (argv.verbose) {
        Object.keys(builders).forEach(function (name) {
            var builder = builders[name];
            spinLogger.log(name + " = ", require('util').inspect(builder.config, false, null));
        });
    }
    if (cmd === 'exp') {
        startExp(options, spinLogger);
    }
    else if (cmd === 'test') {
        var mochaWebpack = child_process_1.spawn(path.join(process.cwd(), 'node_modules/.bin/mocha-webpack'), ['--include', 'babel-polyfill', '--webpack-config', 'node_modules/spinjs/webpack.config.js'].concat(process.argv.slice(process.argv.indexOf('test') + 1)), {
            stdio: [0, 1, 2]
        });
        mochaWebpack.on('close', function (code) {
            process.exit(code);
        });
    }
    else {
        var expoPlatforms_2 = [];
        var watch_1 = cmd === 'watch';
        var platforms_1 = {};
        Object.keys(builders).forEach(function (name) {
            var builder = builders[name];
            var stack = builder.stack;
            platforms_1[stack.platform] = true;
            if (stack.hasAny('react-native') && stack.hasAny('ios')) {
                expoPlatforms_2.push('ios');
            }
            else if (stack.hasAny('react-native') && stack.hasAny('android')) {
                expoPlatforms_2.push('android');
            }
        });
        var prepareExpoPromise = watch_1 && expoPlatforms_2.length > 0 ? allocateExpoPorts(expoPlatforms_2) : Promise.resolve();
        prepareExpoPromise.then(function () {
            var _loop_1 = function (name) {
                var builder = builders[name];
                var stack = builder.stack;
                if (stack.hasAny(['dll', 'test'])) {
                    return "continue";
                }
                var prepareDllPromise = cmd === 'watch' && options.webpackDll && builder.child
                    ? buildDll(stack.platform, builder.child.config, options)
                    : Promise.resolve();
                prepareDllPromise.then(function () { return startWebpack(platforms_1, watch_1, builder, options); });
            };
            for (var _i = 0, _a = Object.keys(builders); _i < _a.length; _i++) {
                var name = _a[_i];
                _loop_1(name);
            }
        });
    }
};
exports.default = execute;
//# sourceMappingURL=executor.js.map